## Вопросы к РГР по предмету "Технологии программирования". 1 курс, 2025

### 1. Почему преобразование значений типа int к типу float, начиная с определённого числа, происходит с погрешностью?

float - одинарная точность (4 байта).

float состоит из мантиссы (23 бита) и экспоненты. Если целое число слишком большое, оно не поместится в мантиссу и округлится. Это и будет погрешность.

### 2. Что будет, если локальную переменную функции определить static
Тогда переменная будет храниться в статической (а не автоматической памяти) и будет хранить свое значение между вызовами функций. Инициализация переменной произойдет только при первом вызове функции.

### 3. Почему время доступа к элементу массива по индексу O(1)?
Массив хранится в памяти в виде подряд идущих ячеек памяти. Если говорить о динамическом массиве, то его указатель - это указатель на его первую ячейку. 

Благодаря механизму адресной арифметики можно прибавить к указателю на первую ячейку число (индекс) и получить нужный элемент, не перебирая массив.

### 4. Что такое header guard?
конструкция, позволяющая включать содержимое заголовочного файла только 1 раз при компиляции. Иначе дублирование определения функций, методов и классов привело бы к ошибке препроцессинга.

Используются директивы препроцессора:
#ifndef
#define
#endif 

Раньше юзали #pragma once, но этот способ устарел.

### 5. Для чего нужны виртуальные функции?
Виртуальные функции обеспечивают переопределение методов базового класса производным классом при наследовании. 

Класс, определяющий или наследующий виртуальную функцию - полиморфный класс.

Еще существуют чистые виртуальные функции - они не имеют определения и подразумевают, что определение появится в производных классах. Абстрактные классы состоят из чистых виртуальных функций. 

### 6. Почему наследование от класса с НЕвиртуальным деструктором может быть небезопасным?

Если объект производного класса удаляется через указатель базового класса с невиртуальным деструктором (апкаст), то вызовется деструктор базового класса. 

Деструктор производного класса вызван не будет - тогда ресурсы внутри производного класса могут быть освобождены неправильно. Может произойти утечка памяти или UB.
### 7. Как работает dynamic_cast?
dynamic_cast делает downcast в рантайме - преобразует указатели и ссылки базового класса в указатели и ссылки производного класса.

Еще dynamic_cast может делать crosscast в рамках множественного наследования.

Если невозможно преобразовать указатель, вернет nullptr.

Если невозможно преобразовать ссылку, выбросит std::bad_cast

### 8. Как компилятор определяет, когда использовать конструктор копирования, а когда конструктор перемещения?

Конструктор копирования работает с lvalue - с объектами, переменными и сущностями, у которых есть адрес в памяти. 

Конструктор перемещения работает с rvalue - с тем, у чего нет адреса в памяти. Работа происходит в формате rvalue-ссылок. Причем сама по себе rvalue-ссылка является lvalue.

Как получить rvalue - временный объект возврата из функции, std::move() и тд...

### 9. 

### 10. 

### 11. 

### 12. Когда следует использовать перегрузку, а когда шаблон функции?
Перегрузка используетсяo, когда нужно выполнить действия с несколькими (немногими) типами данных. Если функция нужна только для работы со строками и символами - есть смысл писать 2 перегрузки, а не шаблон.

Если действие может быть выполнено с множеством различных типов данных, то перегрузка сильно раздувает объем кода - нужно использовать шаблон.

### 13. Что такое специализация шаблона?
Написанный шаблон класса или шаблон функции можно уточнить для конкретного типа данных. Написать код для шаблона, если в него будет помещен конкретно этот тип данных. 

Специализация может быть полной - когда указаны значения всех параметров шаблона.

Специализация может быть частичной - значения указаны не для всех параметров шаблона.

### 14. Какие флаги состояния есть у потоков ввода/вывода? Как с ними взаимодействовать?
- good() - поток функционирует нормально.
- bad() - поток сломан, восстановить нельзя. Нужно завершать программу. 
- fail() - ошибка данных в потоке. Можно сбросить методом clear() и работать с потоком дальше.
- eof() - конец файла.

Поток кастуется к true, если у него флаг good()

Метод setstate() задает флаг потока
```c++
std::cin.setstate(std::ios_base::failbit);
```