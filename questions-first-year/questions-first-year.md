## Вопросы к РГР по предмету "Технологии программирования". 1 курс, 2025

### 1. Почему преобразование значений типа int к типу float, начиная с определённого числа, происходит с погрешностью?

float - одинарная точность (4 байта).

float состоит из мантиссы (23 бита) и экспоненты. Если целое число слишком большое, оно не поместится в мантиссу и округлится. Это и будет погрешность.

### 2. Что будет, если локальную переменную функции определить static
Тогда переменная будет храниться в статической (а не автоматической памяти) и будет хранить свое значение между вызовами функций. Инициализация переменной произойдет только при первом вызове функции.

### 3. Почему время доступа к элементу массива по индексу O(1)?
Массив хранится в памяти в виде подряд идущих ячеек памяти. Если говорить о динамическом массиве, то его указатель - это указатель на его первую ячейку. 

Благодаря механизму адресной арифметики можно прибавить к указателю на первую ячейку число (индекс) и получить нужный элемент, не перебирая массив.

### 4. Что такое header guard?
конструкция, позволяющая включать содержимое заголовочного файла только 1 раз при компиляции. Иначе дублирование определения функций, методов и классов привело бы к ошибке препроцессинга.

Используются директивы препроцессора:
#ifndef
#define
#endif 

Раньше юзали #pragma once, но этот способ устарел.

### 5. Для чего нужны виртуальные функции?
Виртуальные функции обеспечивают переопределение методов базового класса производным классом при наследовании. 

Класс, определяющий или наследующий виртуальную функцию - полиморфный класс.

Еще существуют чистые виртуальные функции - они не имеют определения и подразумевают, что определение появится в производных классах. Абстрактные классы состоят из чистых виртуальных функций. 

### 6. Почему наследование от класса с НЕвиртуальным деструктором может быть небезопасным?

Если объект производного класса удаляется через указатель базового класса с невиртуальным деструктором (апкаст), то вызовется деструктор базового класса. 

Деструктор производного класса вызван не будет - тогда ресурсы внутри производного класса могут быть освобождены неправильно. Может произойти утечка памяти или UB.
### 7. Как работает dynamic_cast?
dynamic_cast делает downcast в рантайме - преобразует указатели и ссылки базового класса в указатели и ссылки производного класса.

Еще dynamic_cast может делать crosscast в рамках множественного наследования.

Если невозможно преобразовать указатель, вернет nullptr.

Если невозможно преобразовать ссылку, выбросит std::bad_cast

### 8. Как компилятор определяет, когда использовать конструктор копирования, а когда конструктор перемещения?

Конструктор копирования работает с lvalue - с объектами, переменными и сущностями, у которых есть адрес в памяти. 

Конструктор перемещения работает с rvalue - с тем, у чего нет адреса в памяти. Работа происходит в формате rvalue-ссылок. Причем сама по себе rvalue-ссылка является lvalue.

Как получить rvalue - временный объект возврата из функции, std::move() и тд...

### 9. гарантии безопасности исключений
- Гарантия отсутствия исключений. Исключения не выбрасываются ни в коем случае.
- Базовая гарантия. После выброса исключения все объекты и сущности работоспособны, но их состояние может быть изменено.
- Строгая гарантия. После выброса исключения все объекты работоспособны, а их состояние неизменно.

### 10. отличие malloc от new
Malloc - это выделение памяти в стиле С. Память выделяется в Heap. Malloc выделяет неинициализированный блок памяти, нужно вручную инициализировать объекты в памяти перед использованием. И еще malloc вернет void*, который надо кастовать к указателю нужного типа. 

new - это выделение памяти в стиле c++, внутри free store. New выделяет и автоматически инициализирует память, например вызывает конструктор объекта. New сразу вернет указатель нужного типа.

### 11. Что такое умный указатель, какие умные указатели есть в stl?
Умный указатель - класс, имитирующий поведение обычного указателя, но имеющий автоматическое удаление после своего использования. 

Есть 3 типа умных указателей:
- unique_ptr - обладает единственностью владения объектом. Только один unique_ptr может указывать на этот объект в это время. Объект очищается при уничтожении этого указателя.
- shared_ptr - несколько указателей владеют одним объектом. Внутри работает статическая переменная-счетчик, которая уничтожает объект только по уничтожении последнего указывающего на объект shared_ptr. Это удобно, но возникает проблема циклических ссылок.
- weak_ptr - не владеет объектом и не влияет на счетчкик shared_ptr. Создан для решения проблемы циклических ссылок.

### 12. Когда следует использовать перегрузку, а когда шаблон функции?
Перегрузка используется, когда нужно выполнить действия с несколькими (немногими) типами данных. Если функция нужна только для работы со строками и символами - есть смысл писать 2 перегрузки, а не шаблон.

Если действие может быть выполнено с множеством различных типов данных, то перегрузка сильно раздувает объем кода - нужно использовать шаблон.

### 13. Что такое специализация шаблона?
Написанный шаблон класса или шаблон функции можно уточнить для конкретного типа данных. Написать код для шаблона, если в него будет помещен конкретно этот тип данных. 

Специализация может быть полной - когда указаны значения всех параметров шаблона.

Специализация может быть частичной - значения указаны не для всех параметров шаблона.

### 14. Какие флаги состояния есть у потоков ввода/вывода? Как с ними взаимодействовать?
- good() - поток функционирует нормально.
- bad() - поток сломан, восстановить нельзя. Нужно завершать программу. 
- fail() - ошибка данных в потоке. Можно сбросить методом clear() и работать с потоком дальше.
- eof() - конец файла.

Поток кастуется к true, если у него флаг good()

Метод setstate() задает флаг потока
```c++
std::cin.setstate(std::ios_base::failbit);
```

### 15. Какие категории итераторов используются в stl?
- входной итератор - только чтение, запись запрещена. std::istream_iterator

- выходной итератор - только запись, чтение запрещено. std::ostream_iterator

- прямой итератор - только инкремент, идти на 1 шаг вперед по контейнеру. Например, итератор для std::forward_list

- двусторонний итератор, можно делать инкремент и декремент. Например, итератор std::list

- итератор произвольного доступа - можно перемещаться вперед или назад на n позиций. Например, итератор для std::vector


### 16. Что такое инвалидация итераторов?
Инвалидация итераторов - когда после некоторых действий с контейнерами, итераторы на эти контейнеры становятся непригодными для использования. 

Например, если в vector взять итератор и удалить из него элемент, то итератор может перестать указывать туда, куда должен. Разыменовывание такого итератора может вызвать UB.

Или если в vector добавить элемент, то возможна переаллокация памяти (расширение массива под капотом) - тогда итераторы инвалидироавны будут.

В документации расписаны методы контейнеров, которые могут привести к инвалидации.

### 17. В чем разница между size и capacity в vector?
vector - это аналог ArrayList, то есть это расширяемый массив. Под капотом у vector работает обычный массив фиксированной длины, который расширяется в случае чего. Но при создании vector этот массив под копотом имеет размер capacity, причем capacity >= size (кол-ва элементов вектора).

### 18. Что такое функтор?
Функтор - любой объект, реализующий оператор ().
- Это может быть объект класса с таким перегруженным оператором.
- Это может быть указатель на функцию.

### 19. Какие последовательные контейнеры есть в stl?
- std::vector - аналог ArrayList, массив расширяемой длины.
- std::array - аналог обычного массива фиксированной длины.
- std::list - двунаправленный LinkedList.
- std::forward_list - односвязанный LinkedList.
- std::dequeue - двунаправленная очередь

Еще есть адаптеры - набор АПИ на основе других контейнеров
- std::stack
- std::queue
- std::priority_queue

### 20. Какие ассоциативные контейнеры есть в stl?
- set - множество, хранящее уникальные элементы. По умолчанию, в порядке возрастания

- map - словарь "ключ-значение". Ключи уникальны, а контейнер сортируется по ключам.

- multimap - то же, что и map, но можно иметь повторяющиеся ключи.