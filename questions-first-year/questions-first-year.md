### Вопросы к РГР по предмету "Технологии программирования". 1 курс, 2025

#### 1. Почему преобразование значений типа int к типу float, начиная с определённого числа, происходит с погрешностью?

float - одинарная точность (4 байта).

float состоит из мантиссы (23 бита) и экспоненты. Если целое число слишком большое, оно не поместится в мантиссу и округлится. Это и будет погрешность.

#### 2. Что будет, если локальную переменную функции определить static
Тогда переменная будет храниться в статической (а не автоматической памяти) и будет хранить свое значение между вызовами функций. Инициализация переменной произойдет только при первом вызове функции.

#### 3. Почему время доступа к элементу массива по индексу O(1)?
Массив хранится в памяти в виде подряд идущих ячеек памяти. Если говорить о динамическом массиве, то его указатель - это указатель на его первую ячейку. 

Благодаря механизму адресной арифметики можно прибавить к указателю на первую ячейку число (индекс) и получить нужный элемент, не перебирая массив.

#### 4. Что такое header guard?
конструкция, позволяющая включать содержимое заголовочного файла только 1 раз при компиляции. Иначе дублирование определения функций, методов и классов привело бы к ошибке препроцессинга.

Используются директивы препроцессора:
#ifndef
#define
#endif 

Раньше юзали #pragma once, но этот способ устарел.

#### 5. Для чего нужны виртуальные функции?
Виртуальные функции обеспечивают переопределение методов базового класса производным классом при наследовании. 

Класс, определяющий или наследующий виртуальную функцию - полиморфный класс.

Еще существуют чистые виртуальные функции - они не имеют определения и подразумевают, что определение появится в производных классах. Абстрактные классы состоят из чистых виртуальных функций. 

#### 6. Почему наследование от класса с НЕвиртуальным деструктором может быть небезопасным?

Если объект производного класса удаляется через указатель базового класса с невиртуальным деструктором (апкаст), то вызовется деструктор базового класса. 

Деструктор производного класса вызван не будет - тогда ресурсы внутри производного класса могут быть освобождены неправильно. Может произойти утечка памяти или UB.
#### 7. Как работает dynamic_cast?
dynamic_cast делает downcast в рантайме - преобразует указатели и ссылки базового класса в указатели и ссылки производного класса.

Еще dynamic_cast может делать crosscast в рамках множественного наследования.

Если невозможно преобразовать указатель, вернет nullptr.

Если невозможно преобразовать ссылку, выбросит std::bad_cast

#### 8. Как компилятор определяет, когда использовать конструктор копирования, а когда конструктор перемещения?

Конструктор копирования работает с lvalue - с объектами, переменными и сущностями, у которых есть адрес в памяти. 

Конструктор перемещения работает с rvalue - с тем, у чего нет адреса в памяти. Работа происходит в формате rvalue-ссылок. Причем сама по себе rvalue-ссылка является lvalue.

Как получить rvalue - временный объект возврата из функции, std::move() и тд...

